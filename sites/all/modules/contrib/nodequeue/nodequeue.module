<?php
// $Id: nodequeue.module,v 1.106 2010/03/16 22:10:45 ezrag Exp $

/**
 * @file
 * Maintains queues of nodes in arbitrary order.
 */

define('NODEQUEUE_OK', 0);
define('NODEQUEUE_INVALID_POSITION', 1);
define('NODEQUEUE_INVALID_NID', 2);
define('NODEQUEUE_DUPLICATE_POSITION', 3);

/* --- HOOKS ---------------------------------------------------------------- */

/**
 * Implementation of hook_perm
 */
function nodequeue_perm() {
  return array('manipulate queues', 'administer nodequeue', 'manipulate all queues');
}

/**
 * Implementation of hook_init().
 *
 * Loads subsidiary includes for other modules.
 */
function nodequeue_init() {
  include_once drupal_get_path('module', 'nodequeue') .'/includes/nodequeue.actions.inc';
}

/**
 * Implementation of hook_menu
 */
function nodequeue_menu() {
  $items = array();

  $admin_access = array('administer nodequeue');
  $access = array('manipulate queues');

  // administrative items
  $items['admin/content/nodequeue'] = array(
    'title' => 'Nodequeue',
    'access callback' => '_nodequeue_access_admin_or_manipulate',
    'page callback' => 'nodequeue_view_queues',
    'description' => 'Create and maintain simple nodequeues.',
    'type' => MENU_NORMAL_ITEM
  );
  $items['admin/content/nodequeue/list'] = array(
    'title' => 'List',
    'access callback' => '_nodequeue_access_admin_or_manipulate',
    'page callback' => 'nodequeue_view_queues',
    'weight' => -1,
    'type' => MENU_DEFAULT_LOCAL_TASK
  );
  $items['admin/content/nodequeue/settings'] = array(
    'title' => 'Settings',
    'access arguments' => $admin_access,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodequeue_admin_settings'),
    'type' => MENU_LOCAL_TASK
  );
  $items['nodequeue/autocomplete'] = array(
    'title' => 'Autocomplete',
    'access arguments' => $access,
    'page callback' => 'nodequeue_autocomplete',
    'type' => MENU_CALLBACK
  );
  $info = nodequeue_api_info();
  foreach ($info as $key => $data) {
    $items['admin/content/nodequeue/add/'. $key] = array(
      'title' => 'Add @type',
      'title arguments' => array('@type' => strtolower($data['title'])),
      'access arguments' => $admin_access,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('nodequeue_edit_queue_form', $key),
      'type' => MENU_LOCAL_TASK
    );
  }
  $items['node/%node/nodequeue'] = array(
    'title' => '@tab',
    'title arguments' => array('@tab' => variable_get('nodequeue_tab_name', 'Nodequeue')),
    'access callback' => 'nodequeue_node_tab_access',
    'access arguments' => array(1),
    'page callback' => 'nodequeue_node_tab',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5
  );

  // Administrative items for an individual queue.
  $items['admin/content/nodequeue/%nodequeue'] = array(
    'access arguments' => array(3),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'nodequeue_admin_view',
    'page arguments' => array(3),
    'type' => MENU_CALLBACK
  );
  $items['admin/content/nodequeue/%nodequeue/view/%subqueue'] = array(
    'title' => 'View',
    'access arguments' => array(3, 5),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'nodequeue_admin_view',
    'page arguments' => array(3, 5),
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK
  );
  // Actual administrative items.
  $items['admin/content/nodequeue/%nodequeue/edit'] = array(
    'title' => 'Edit',
    'access arguments' => $admin_access,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodequeue_edit_queue_form', 3),
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/content/nodequeue/%nodequeue/delete'] = array(
    'title' => 'Delete',
    'access arguments' => $admin_access,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodequeue_admin_delete', 3),
    'weight' => 5,
    'type' => MENU_CALLBACK
  );
  $items["admin/content/nodequeue/%nodequeue/add/%subqueue/%node"] = array(
    'access arguments' => array(6, 3, 5),
    'access callback' => 'nodequeue_node_and_queue_access',
    'page callback' => 'nodequeue_admin_add_node',
    'page arguments' => array(3, 5, 6),
    'type' => MENU_CALLBACK
  );
  $items["admin/content/nodequeue/%nodequeue/remove-node/%subqueue/%node"] = array(
    'access arguments' => array(6, 3, 5),
    'access callback' => 'nodequeue_node_and_queue_access',
    'page callback' => 'nodequeue_admin_remove_node',
    'page arguments' => array(3, 5, 6),
    'type' => MENU_CALLBACK
  );
  $items["admin/content/nodequeue/%nodequeue/clear/%subqueue"] = array(
    'title' => 'Clear',
    'access arguments' => array(3, 5),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodequeue_clear_confirm', 3, 5),
    'type' => MENU_CALLBACK
  );

  return $items;
}
/**
 * Implementation of hook_nodeapi
 */
function nodequeue_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch ($op) {
    case 'delete':
      // If a node is being deleted, ensure it's also removed from any queues.
      $result = db_query("SELECT qid, sqid FROM {nodequeue_nodes} WHERE nid = %d", $node->nid);
      while ($obj = db_fetch_object($result)) {
        // If the queue is being tracked by translation set and the node is part
        // of a translation set, don't delete the queue record.
        // Instead, data will be updated in the 'translation_change' op, below.
        $queues = nodequeue_load_queues(array($obj->qid));
        $queue = array_shift($queues);
        if (!$queue->i18n || (isset($node->tnid) && empty($node->tnid))) {
          // This removes by nid, not position, because if we happen to have a
          // node in a queue twice, the 2nd position would be wrong.
          nodequeue_subqueue_remove_node($obj->sqid, $node->nid);
        }
      }
      break;
    case 'translation_change':
      if (isset($node->translation_change)) {
        // If there is only one node remaining, track by nid rather than tnid.
        // Otherwise, use the new tnid.
        $content_id = $node->translation_change['new_tnid'] == 0 ? $node->translation_change['remaining_nid'] : $node->translation_change['new_tnid'];
        db_query("UPDATE {nodequeue_nodes} SET nid = %d WHERE nid = %d", $content_id, $node->translation_change['old_tnid']);
      }
  }
}

/**
 * Implementation of hook_link
 */
function nodequeue_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();

  if ($type == 'node' &&
      variable_get('nodequeue_links', FALSE) &&
      user_access('manipulate queues')) {
    $queues = nodequeue_load_queues_by_type($node->type, 'links');
    $subqueues = nodequeue_get_subqueues_by_node($queues, $node);
    if (empty($subqueues)) {
      return;
    }

    // resort the subqueues to retain consistent ordering:

    ksort($subqueues);
    // Due to caching, we can accidentally get positions leftover
    // from previous iterations on teaser list pages, so we must
    // remove any existing positions here.
    foreach ($subqueues as $id => $subqueue) {
      unset($subqueues[$id]->position);
    }

    if(!module_exists('translation')) {
      nodequeue_set_subqueue_positions($subqueues, $node->nid);
    }

    foreach ($subqueues as $subqueue) {
      $queue = $queues[$subqueue->qid];
      $id = nodequeue_get_content_id($queue, $node);
      if(module_exists('translation')) {
        $subqueue = array($subqueue->sqid => $subqueue);
        nodequeue_set_subqueue_positions($subqueue, $id);
        $subqueue = array_shift($subqueue);
      }
      $query_string = nodequeue_get_query_string($id, TRUE);
      $class = 'nodequeue-ajax-toggle nodequeue-toggle-q-'. $queue->qid. ' nodequeue-toggle-sq-'. $subqueue->sqid .' nodequeue-toggle-ref-'. $subqueue->reference;
      if (!isset($subqueue->position)) {
        $links[$class] = array(
          'title' => nodequeue_title_substitute($queue->link, $queue, $subqueue),
          'href' => "admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$id",
          'attributes' => array('class' => $class . ' toggle-add'),
          'query' => $query_string);
      }
      else if ($queue->link_remove) {
        $links[$class] = array(
          'title' => nodequeue_title_substitute($queue->link_remove, $queue, $subqueue),
          'href' => "admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$id",
          'attributes' => array('class' => $class .' toggle-remove'),
          'query' => $query_string);
      }
    }
    drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');
    drupal_add_css(drupal_get_path('module', 'nodequeue') .'/nodequeue.css');
  }
  return $links;
}

/**
 * Implementation of hook_theme().
 */
function nodequeue_theme() {
  return array(
    'nodequeue_arrange_subqueue_form' => array(
      'arguments' => array('form'),
    ),
    'nodequeue_subqueue_empty_text' => array(
      'arguments' => array(),
    ),
    'nodequeue_subqueue_full_text' => array(
      'arguments' => array(),
    ),
    'nodequeue_subqueue_count_text' => array(
      'arguments' => array(),
    ),
  );
}

/**
 * Implementation of hook_elements().
 */
function nodequeue_elements() {
  $type = array();

  $type['position'] = array(
    '#input'         => TRUE,
    '#delta'         => 10,
    '#default_value' => 0,
    '#process'       => array('process_position', 'form_expand_ahah'),
  );

  return $type;
}

/**
 * Expand position elements into selects. Works like the weight element, except
 * only positive values are allowed.
 */
function process_position($element) {
  for ($n = 1; $n <= $element['#delta']; $n++) {
    $positions[$n] = $n;
  }

  $element['#options']      = $positions;
  $element['#options']['r'] = t('Remove');
  $element['#type']         = 'select';

  // add default properties for the select element
  $element += _element_info('select');

  return $element;
}

/**
 * If no default value is set for position select boxes, use 1.
 */
function position_value(&$form) {
  if (isset($form['#default_value'])) {
    $form['#value'] = $form['#default_value'];
  }
  else {
    $form['#value'] = 1;
  }
}

/**
 * Implementation of hook_views_api()
 */
function nodequeue_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'nodequeue') .'/includes/views',
  );
}

/**
 * Implementation of hook_form_$form-id_alter().
 */
function nodequeue_form_apachesolr_search_bias_form_alter(&$form, $form_state) {
  // setup for the form building
  $weights = drupal_map_assoc(array('21.0', '13.0', '8.0', '5.0', '3.0', '2.0', '1.0', '0.8', '0.5', '0.3', '0.2', '0.1'));
  $weights['0'] = t('Normal');
  $queues = nodequeue_load_subqueues_by_queue(array_keys(nodequeue_get_all_qids()));

  // build the form
  $form['biasing']['nodequeue_boost'] = array(
    '#type' => 'fieldset',
    '#title' => t('Nodequeue Biasing'),
    '#weight' => -5,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['biasing']['nodequeue_boost']['nodequeue_apachesolr_boost'] = array(
    '#type' => 'item',
    '#description' => t("Specify to bias the search result when a node is in a queue. Any value except <em>Normal</em> will increase the socre for the given queue in the search results"),
  );
  foreach ($queues as $sqid => $queue) {
    $boost = variable_get("nodequeue_apachesolr_boost_$sqid", 0);
    // add in setting for each queue
    $form['biasing']['nodequeue_boost']['nodequeue_apachesolr_boost']["nodequeue_apachesolr_boost_$sqid"] = array(
      '#type' => 'select',
      '#title' => t('Weight for %title nodequeue', array('%title' => $queue->title)),
      '#options' => $weights,
      '#default_value' => $boost,
    );
  }
}

/**
 * Implementation of hook_apachesolr_update_index().
 */
function nodequeue_apachesolr_update_index(&$document, $node) {
  if (empty($document)) {
    return;
  }

  $queues = nodequeue_load_queues(array_keys(nodequeue_get_all_qids()));
  $subqueues = nodequeue_get_subqueues_by_node($queues, $node);

  nodequeue_set_subqueue_positions($subqueues, $node->nid);
  if (is_array($subqueues)) {
    foreach ($subqueues as $sqid => $subqueue) {
      if (!empty($subqueue->position)) {
        $key = _nodequeue_solr_qid_key();
        $document->setMultiValue($key, $sqid);
      }
    }
  }
}

/**
 * return the apachesolr index key for group id
 */
function _nodequeue_solr_qid_key() {
  $qid_key = array(
    'index_type' => 'sint',
    'multiple' => TRUE,
    'name' => "nodequeue",
  );

  return apachesolr_index_key($qid_key);
}

/**
 * Implementation of hook_apachesolr_modify_query().
 */
function nodequeue_apachesolr_modify_query($query, &$params, $caller) {
  $queues = nodequeue_load_subqueues_by_queue(array_keys(nodequeue_get_all_qids()));
  $added = FALSE;
  foreach ($queues as $sqid => $queue) {
    $boost = variable_get("nodequeue_apachesolr_boost_$sqid", 0);
    if (!empty($boost)) {
      $params['bq'][] = _nodequeue_solr_qid_key() . ":$sqid^$boost";
      if (!$added) {
        // Only want to add the facet.field once. no need to repeat it
        $params['facet.field'][] = _nodequeue_solr_qid_key();
        $added = TRUE;
      }
    }
  }
}

// --------------------------------------------------------------------------
// Nodequeue Admin operations

/**
 * Print the JSON output for our AJAX calls.
 */
function nodequeue_js_output($label, $href, $count = NULL, $sqid = NULL) {
  $return = new stdClass();
  $return->status = 1;
  $return->label = check_plain($label);
  $return->href = $href;
  if (isset($count)) {
    $return->count = $count;
  }
  if (isset($sqid)) {
    $return->sqid = $sqid;
  }

  drupal_json($return);
  exit;
}

/**
 * Return content id based on i18n settings
 */
function nodequeue_get_content_id($queue, $node) {
  return ($queue->i18n && !empty($node->tnid)) ? $node->tnid : $node->nid;
}

/**
 * Page callback to add a node to a queue.
 */
function nodequeue_admin_add_node($queue, $subqueue, $node) {
  if (!nodequeue_check_token($node->nid)) {
    return drupal_goto();
  }
  $id = nodequeue_get_content_id($queue, $node);
  nodequeue_subqueue_add($queue, $subqueue, $id);

  // Provide a response if this is javascript.
  if (!empty($_POST['js'])) {
    if (isset($_GET['tab'])) {
      nodequeue_js_output(t('Remove from queue'),
        url("admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid", array('query' => nodequeue_get_query_string($node->nid, TRUE, array('tab')))),
        nodequeue_subqueue_size_text($queue->size, $queue->size ? min($subqueue->count, $queue->size) : $subqueue->count, FALSE),
        $subqueue->sqid);
    }
    else {
      nodequeue_js_output(nodequeue_title_substitute($queue->link_remove, $queue, $subqueue),
        url("admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid", array('query' => nodequeue_get_query_string($node->nid, TRUE))));
    }
  }

  // There should always be a destination set for this, so just goto wherever.
  drupal_goto();
}

/**
 * Page callback to remove a node from a queue.
 */
function nodequeue_admin_remove_node($queue, $subqueue, $node) {
  if (!nodequeue_check_token($node->nid)) {
    return drupal_goto();
  }
  $id = nodequeue_get_content_id($queue, $node);
  nodequeue_subqueue_remove_node($subqueue->sqid, $id);

  // Provide a response if this is javascript.
  if (!empty($_POST['js'])) {
    if (isset($_GET['tab'])) {
      nodequeue_js_output(t('Add to queue'),
        url("admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid", array('query' => nodequeue_get_query_string($node->nid, TRUE, array('tab')))),
        nodequeue_subqueue_size_text($queue->size, $subqueue->count - 1, FALSE),
        $subqueue->sqid);
    }
    else {
      nodequeue_js_output(nodequeue_title_substitute($queue->link, $queue, $subqueue),
        url("admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid", array('query' => nodequeue_get_query_string($node->nid, TRUE))));
    }
  }

  // There should always be a destination set for this, so just goto wherever.
  drupal_goto();
}

/**
 * Display the queue controls for a node.
 *
 * @param $node
 *   The loaded $node; will be loaded by the hook_menu.
 */
function nodequeue_node_tab($node) {
  $output = '';

  // moved from hook_menu due to architecture change.  This function seems to only be called from menu anyway...
  $queues = nodequeue_load_queues_by_type($node->type, 'tab');
  if (!$queues) {
    return FALSE;
  }
  $header = array();
  $header[] = array('data' => t('Title'), 'class' => 'nodequeue-title');
  if (variable_get('nodequeue_tab_display_max', 1)) {
    $header[] = array('data' => t('Max nodes'), 'class' => 'nodequeue-max-nodes');
  }
  $header[] = array('data' => t('In queue'), 'class' => 'nodequeue-in-queue');
  $header[] = array('data' => t('Operation'), 'class' => 'nodequeue-operation');
  $subqueues = nodequeue_get_subqueues_by_node($queues, $node);

  nodequeue_set_subqueue_positions($subqueues, $node->nid);

  $rows = array();
  foreach ($subqueues as $subqueue) {
    $queue = $queues[$subqueue->qid];
    if (empty($subqueue->position)) {
      $op = l(
        t('Add to queue'),
        "admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid",
        array('attributes' => array('class' => 'nodequeue-ajax-toggle'),
          'query' => drupal_get_destination() .'&tab&'. nodequeue_get_token($node->nid))
      );
    }
    else {
      $op = l(
        t('Remove from queue'),
        "admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid",
        array('attributes' => array('class' => 'nodequeue-ajax-toggle'),
          'query' => drupal_get_destination() .'&tab&'. nodequeue_get_token($node->nid))
      );
    }
    $row = array();
    $row[] = array(
      'class' => 'nodequeue-title',
      'data' => l(nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue), "admin/content/nodequeue/$queue->qid/view/$subqueue->sqid"),
    );
    if (variable_get('nodequeue_tab_display_max', 1)) {
      $row[] = array('class' => 'nodequeue-max-nodes', 'data' => $queue->size ? $queue->size : t('Infinite'));
    }
    $row[] = array(
      'id' => 'nodequeue-count-'. $subqueue->sqid,
      'class' => 'nodequeue-in-queue',
      'data' => nodequeue_subqueue_size_text($queue->size, $subqueue->count, FALSE)
    );
    $row[] = array('class' => 'nodequeue-operation', 'data' => $op);
    $rows[] = $row;
  }

  $output .= theme('table', $header, $rows, array('class' => 'nodequeue-table'));
  drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');
  drupal_add_css(drupal_get_path('module', 'nodequeue') .'/nodequeue.css');
  return $output;
}

/**
 * Display a list of queues and their status for the administrator.
 */
function nodequeue_view_queues() {
  $output = theme('advanced_help_topic', 'nodequeue', 'about', 'icon') . '&nbsp;' . theme('advanced_help_topic', 'nodequeue', 'about', t('Click here for information about this module'));
  // Fetch all of the queues.
  $queues = nodequeue_load_queues(nodequeue_get_all_qids(25));
  foreach ($queues as $queue) {
    if (!nodequeue_queue_access($queue)) {
      unset($queues[$queue->qid]);
    }
  }

  if (empty($queues)) {
    return $output . t('No nodequeues exist.');
  }

  $header = array(
    array('data' => t('Title'), 'field' => 'title', 'sort' => 'asc'),
    array('data' => t('Max nodes'), 'field' => 'size'),
    array('data' => t('Subqueues'), 'field' => 'subqueues'),
    array('data' => t('Operation')),
  );
  $table_sort = tablesort_init($header);

  $qids = array();
  $sort_primary = array();
  $sort_secondary = array();
  $sort_direction_regular = array('asc' => SORT_ASC, 'desc' => SORT_DESC);
  $sort_direction_reverse = array('asc' => SORT_DESC, 'desc' => SORT_ASC);
  foreach ($queues as $queue) {
    // If a queue has only one subqueue, store the qid so we can display
    // the number of nodes in the subqueue.
    if ($queue->subqueues == 1) {
      $qids[] = $queue->qid;
    }
    $sort_secondary[] = $queue->title;
    switch ($table_sort['sql']) {
      case 'title':
      default:
        $sort_primary[] = $queue->title;
        $sort_direction = $sort_direction_regular;
        break;
      case 'size':
        $sort_primary[] = $queue->size;
        $sort_direction = $sort_direction_reverse;
        break;
      case 'subqueues':
        $sort_primary[] = $queue->subqueues;
        $sort_direction = $sort_direction_regular;
        break;
    }
  }

  $subqueues = nodequeue_load_subqueues_by_queue($qids);
  // Relate all the subqueues we loaded back to our queues.
  foreach ($subqueues as $subqueue) {
     if (nodequeue_api_subqueue_access($subqueue, NULL, $queues[$subqueue->qid])) {
       $queues[$subqueue->qid]->subqueue = $subqueue;
     }
  }

  if (!empty($table_sort)) {
    if (strtolower($table_sort['sort']) == 'desc') {
      array_multisort($sort_primary, $sort_direction['desc'], $sort_secondary, $queues); // Re-indexes array keys; key no longer equals qid.
    }
    else {
      array_multisort($sort_primary, $sort_direction['asc'], $sort_secondary, $queues); // Re-indexes array keys; key no longer equals qid.
    }
  }

  $rows = array();
  foreach ($queues as $queue) {
    $sub_text = $queue->subqueues;
    if ($sub_text == 1) {
      $sub_text .= " (". nodequeue_subqueue_size_text($queue->size, $queue->subqueue->count) .")";
    }

    $operations = array(l(t('View'), "admin/content/nodequeue/$queue->qid/view"));
    if (user_access('administer nodequeue')) {
      $operations[] = l(t('Edit'), "admin/content/nodequeue/$queue->qid/edit");
      $operations[] = l(t('Delete'), "admin/content/nodequeue/$queue->qid/delete");
    }

    $rows[] = array(
      array('class' => 'nodequeue-title', 'data' => check_plain($queue->title)),
      array('class' => 'nodequeue-max-nodes', 'data' => $queue->size == 0 ? t('Infinite') : $queue->size),
      array('class' => 'nodequeue-subqueues', 'data' => $sub_text),
      array('class' => 'nodequeue-operation', 'data' => implode(' | ', $operations)),
    );
  }

  $output .= theme('table', $header, $rows);
  $output .= theme('pager', NULL, 25);

  return  $output;
}

/**
 * Display a list of subqueues for a queue and their sizes
 */
function nodequeue_view_subqueues($queue) {
  // Fetch all of the subqueues.
  $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);

  $header = array(t('Title'), t('In queue'), t('Operation'));

  $rows = array();
  foreach ($subqueues as $subqueue) {
    if (nodequeue_api_subqueue_access($subqueue, NULL, $queue)) {
      $sub_text = nodequeue_subqueue_size_text($queue->size, $subqueue->count, FALSE);
      $rows[] = array(
        array('class' => 'nodequeue-title', 'data' => check_plain($subqueue->title)),
        array('class' => 'nodequeue-subqueues', 'data' => $sub_text),
        array('class' => 'nodequeue-operation', 'data' => l(t('View'), "admin/content/nodequeue/$queue->qid/view/$subqueue->sqid"))
      );
    }
  }

  $output = '<p>'. t('Max nodes in queue: @size', array('@size' => $queue->size ? $queue->size : t("Infinite"))) .'</p>';
  $output .= theme('table', $header, $rows);
  $output .= theme('pager', NULL, 20);

  return  $output;
}

/**
 * Add or edit a queue.
 */
function nodequeue_edit_queue_form(&$form_state, $queue) {
  $info = nodequeue_api_info();

  // For adding queues.
  if (is_string($queue)) {
    // If the $queue is a string - name of a queue type, basically - then we test that it's a valid queue type.
    $queue = strtolower($queue);
    if (!isset($info[$queue])) {
      return false;
    }
    drupal_set_title(t('Add @type', array('@type' => strtolower($info[$queue]['title']))));
    $queue = new nodequeue_queue($queue);
  }
  else {
    drupal_set_title(t("Nodequeue '@title'", array('@title' => $queue->title)));
  }

  $form['description'] = array(
    '#type' => 'fieldset',
    '#title' => $info[$queue->owner]['title'],
    '#description' => $info[$queue->owner]['description'],
  );

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#default_value' => $queue->title,
    '#size' => 50,
    '#maxlength' => 64,
    '#description' => t('Enter the name of the queue'),
  );

  // This is a value; as the default nodequeue implementation has just one
  // queue per nodequeue, this field is totally redundant. Plugins can
  // override this.
  $form['subqueue_title'] = array(
    '#type' => 'value',
    '#value' => $queue->subqueue_title,
  );
  // The placeholder is put here so that modifiers have an easy way to put
  // additional form widgets in a prominent spot but not before the title of
  // the queue.
  $form['placeholder'] = array();

  $form['size'] = array(
    '#type' => 'textfield',
    '#title' => t('Queue size'),
    '#default_value' => $queue->size,
    '#size' => 2,
    '#maxlength' => 2,
    '#description' => t('The maximum number of nodes will appear in the queue. Enter 0 for no limit'),
  );

  $form['reverse'] = array(
    '#type' => 'checkbox',
    '#title' => t('Reverse in admin view'),
    '#default_value' => $queue->reverse,
    '#description' => t('Ordinarily queues are arranged with the front of the queue (where items will be removed) on top and the back (where items will be added) on the bottom. If checked, this will display the queue such that items will be added to the top and removed from the bottom.'),
  );

  $form['link'] = array(
    '#type' => 'textfield',
    '#title' => t('Link "add to queue" text'),
    '#default_value' => $queue->link,
    '#size' => 40,
    '#maxlength' => 40,
    '#description' => t('If you want a link to add a node to a queue in the "links" section (next to "add new comment"), enter the text here. If left blank no link will be given; note that enabling this feature for any queue will cause an extra query to be run every time a node is loaded. "%subqueue" will be replaced with the subqueue title, if applicable.'),
  );

  $form['link_remove'] = array(
    '#type' => 'textfield',
    '#title' => t('Link "remove from queue" text'),
    '#default_value' => $queue->link_remove,
    '#size' => 40,
    '#maxlength' => 40,
    '#description' => t('Enter the text for the corresponding link to remove a node from a queue. This may be blank (in which case no link will appear) but a remove link will only appear if link, above, is set.'),
  );


  $result = db_query("SELECT r.* FROM {role} r LEFT JOIN {permission} p ON p.rid = r.rid WHERE p.perm LIKE '%manipulate queues%' ORDER BY r.name");

  $roles = array();
  while ($role = db_fetch_object($result)) {
    $roles[$role->rid] = $role->name;
  }

  if (!empty($roles)) {
    $form['roles'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Roles'),
      '#default_value' => is_array($queue->roles) ? $queue->roles : array(),
      '#options' => $roles,
      '#description' => t('Check each role that can add nodes to the queue. Be sure that roles you want to appear here have "manipulate queues" access in the main access control panel.'),
    );
  }
  else {
    $form['roles'] = array(
      '#type' => 'value',
      '#value' => array(),
    );

    $form['roles_markup'] = array(
      '#value' => t('No roles have the "manipulate queues" permission, so only the administrator account will be able to add or remove items from this queue.'),
    );
  }

  $nodes = node_get_types('names');

  $form['types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Types'),
    '#default_value' => $queue->types,
    '#options' => $nodes,
    '#description' => t('Check each node type that can be added to this queue.'),
  );

  $form['i18n'] = array(
    '#type' => 'radios',
    '#title' => t('Internationalization'),
    '#options' => array(
      '1' => t('Treat translation nodes as a single node'),
      '0' => t('Manually manage translated nodes'),
    ),
    '#default_value' => empty($queue->qid) && module_exists('translation_helpers') ? 0 : $queue->i18n,
    '#description' => t('Treating translations as a single node allows users to add, remove and manipulate a node
      in the queue regardless of which translation is acted upon; nodequeue will only act on the original node.
      When manually managing translation nodes, Nodequeue will ignore the relationship between node translations;
      each translation node must be added to the queue separately and will occupy a separate spot in the queue.
      Changing this setting will <strong>not</strong> update content that is already in the queue.'),
    '#access' => module_exists('translation_helpers'),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  $form['owner'] = array(
    '#type' => 'value',
    '#value' => $queue->owner,
  );

  $form['show_in_links'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_links,
  );

  $form['show_in_tab'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_tab,
  );

  $form['show_in_ui'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_ui,
  );

  $form['reference'] = array(
    '#type' => 'value',
    '#value' => $queue->reference,
  );

  $form['subqueues'] = array(
    '#type' => 'value',
    '#value' => $queue->subqueues,
  );

  if (isset($queue->qid)) {
    $form[] = array(
      '#type' => 'submit',
      '#value' => t('Delete'),
      '#validate' => array('nodequeue_edit_queue_form_delete_validate'),
      '#submit' => array('nodequeue_edit_queue_form_delete_submit'),
    );
    $form['qid'] = array(
      '#type' => 'value',
      '#value' => $queue->qid,
    );
    $form['count'] = array(
      '#type' => 'value',
      '#value' => $queue->count,
    );
  }

  nodequeue_api_queue_form($queue, $form);

  return $form;
}

/**
 * Validate function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_validate($form, &$form_state) {
  if (empty($form_state['values']['title'])) {
    form_set_error('title', t('Please enter a title for this queue.'));
  }
  $queue = (object) $form_state['values'];
  // fix checkboxes
  $queue->roles = array_keys(array_filter($queue->roles));
  $queue->types = array_keys(array_filter($queue->types));

  if (!isset($queue->qid)) {
    $queue->new = TRUE;
  }

  nodequeue_api_queue_form_validate($queue, $form_state, $form);
}

/**
 * Submit function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_submit($formid, &$form_state) {
  $queue = (object) $form_state['values'];
  // fix checkboxes
  $queue->roles = array_keys(array_filter($queue->roles));
  $queue->types = array_keys(array_filter($queue->types));

  if (!isset($queue->qid)) {
    $queue->new = TRUE;
  }

  // Modify show_in_links based on whether or not links are available.
  $queue->show_in_links = !empty($queue->link) || !empty($queue->link_remove);

  nodequeue_api_queue_form_submit($queue, $form_state);

  $qid = nodequeue_save($queue); // sets $queue->qid if needed.

  nodequeue_api_queue_form_submit_finish($queue, $form_state);

  nodequeue_check_subqueue_sizes($queue);

  if ($queue->new) {
    $form_state['values']['qid'] = $qid;
    drupal_set_message(t('The queue has been created.'));
  }
  else {
    drupal_set_message(t('The queue has been updated.'));
  }
  $form_state['redirect'] = 'admin/content/nodequeue';
}

/**
 * Delete-validate function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_delete_validate($form, &$form_state) {
  // No validation for delete step!  But we need to have this so the default validation isn't called.
}

/**
 * Delete-submit function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_delete_submit($formid, &$form_state) {
  $form_state['redirect'] = "admin/content/nodequeue/". $form_state['values']['qid'] ."/delete";
}

/**
 * Confirm form to delete a queue
 */
function nodequeue_admin_delete(&$form_state, $queue) {
  $form['qid'] = array('#type'  => 'value', '#value' => $queue->qid);
  return confirm_form($form,
    t('Are you sure you want to delete "%title"?', array('%title' => $queue->title)),
    isset($_GET['destination']) ? $_GET['destination'] : 'admin/content/nodequeue',
    t('This action cannot be undone.'),
    t('Delete'), t('Cancel')
  );
}

/**
 * Submit function for nodequeue delete
 */
function nodequeue_admin_delete_submit($formid, &$form_state) {
  if ($form_state['values']['confirm']) {
    nodequeue_delete($form_state['values']['qid']);
    drupal_set_message(t('The queue has been deleted.'));
  }
  $form_state['redirect'] = 'admin/content/nodequeue';
}

/**
 * Page callback to view a queue.
 */
function nodequeue_admin_view($queue, $subqueue = array()) {
  drupal_set_title(t("Nodequeue '@title'", array('@title' => $queue->title)));
  $qid = $queue->qid;

  // If the queue has just one subqueue, it gets special treatment.
  if (empty($subqueue->sqid)) {
    if ($queue->subqueues == 1) {
      $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);
      $subqueue = array_shift($subqueues);
    }
    else {
      // display subqueue list page.
      return nodequeue_view_subqueues($queue);
    }
  }
  else if ($subqueue->sqid) {
   if (!nodequeue_api_subqueue_access($subqueue, NULL, $queue)) {
      return drupal_not_found();
    }
    // Adjust properties of the page so our subqueue is in the right
    // visual place.
    drupal_set_title(t("Subqueue '@title'",
      array('@title' => nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue))));
    $breadcrumb = drupal_get_breadcrumb();
    $breadcrumb[] = l($queue->title, "admin/content/nodequeue/$queue->qid");
    drupal_set_breadcrumb($breadcrumb);
  }
  return nodequeue_arrange_subqueue($queue, $subqueue);
}

/**
 * View the contents of a subqueue, with links to re-order the queue.
 */
function nodequeue_arrange_subqueue($queue, $subqueue = NULL) {
  // set title and load subqueue if it's not provided
  drupal_set_title(t("Nodequeue '@title'", array('@title' => $queue->title)));
  if (!$subqueue->sqid) {
    if ($queue->subqueues == 1) {
      $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);
      $subqueue = array_shift($subqueues);
    }
    else {
      return drupal_not_found();
    }
  }
  else if ($subqueue->sqid) {
    if (!nodequeue_api_subqueue_access($subqueue, NULL, $queue)) {
      return drupal_not_found();
    }
    drupal_set_title(t("Subqueue '@title'", array('@title' => nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue))));
  }

  // get nodes from the queue
  $nodes = _nodequeue_dragdrop_get_nodes($queue, $subqueue);

  return drupal_get_form('nodequeue_arrange_subqueue_form', $queue, $nodes, $subqueue);
}

/**
 * Return a list of nodes in a specific subqueue.
 */
function _nodequeue_dragdrop_get_nodes($queue, $subqueue) {
  $order = $queue->reverse ? 'DESC' : 'ASC';

  $visible = nodequeue_nids_visible($subqueue->sqid);

  // get a list of all nodes in the subqueue, regardless of access restrictions
  $result = db_query('SELECT DISTINCT(n.nid), n.title, n.uid, u.name, n.created, nq.position FROM {node} n LEFT JOIN {users} u on n.uid = u.uid LEFT JOIN {nodequeue_nodes} nq ON nq.nid = n.nid WHERE nq.sqid = %d ORDER BY nq.position '. $order, $subqueue->sqid);

  $nodes = array();
  while ($node = db_fetch_object($result)) {
    $node->visible = isset($visible[$node->nid]) ? TRUE : FALSE;
    $nodes[] = $node;
  }

  return $nodes;
}

/**
 * Form definition for nodequeue drag'n'drop form.
 */
function nodequeue_arrange_subqueue_form($form_state, $queue, $nodes, $subqueue) {
  $form = array('#tree' => TRUE);

  // save queue and subqueue objects for later use
  $form['#queue']    = (array) $queue;
  $form['#subqueue'] = (array) $subqueue;

  // prepare the main part of the form which will be themed as a table
  $count = count($nodes);
  foreach ($nodes as $node) {
    $form[$node->nid]['#node'] = (array) $node;
    if ($node->visible) {
      $form[$node->nid]['#node'] = (array) $node;
      $form[$node->nid]['title'] = array('#value' => l($node->title, 'node/'. $node->nid));
      $form[$node->nid]['author'] = array('#value' => theme('username', $node));
      $form[$node->nid]['date'] = array('#value' => format_date($node->created, 'small'));
    }
    else {
      $form[$node->nid]['title'] = array('#value' => t('Restricted node, NID: @nid', array('@nid' => $node->nid)));
      $form[$node->nid]['author'] = array('#value' => '');
      $form[$node->nid]['date'] = array('#value' => '');
    }

    $form[$node->nid]['edit'] = array('#value' => l(t('edit'), 'node/'. $node->nid .'/edit', array('attributes' => array('title' => t('Edit this node')))));
    $form[$node->nid]['position'] = array(
      '#type' => 'position',
      '#delta' => $count,
      '#default_value' => $node->position,
      '#attributes' => array(
        'class' => 'node-position',
      ),
    );

    $attr = array(
      'attributes' => array(
        'title' => t('Remove from queue'),
        'style' => 'display: none;',
        'class' => 'nodequeue-remove',
        'id' => 'nodequeue-remove-'. $node->nid,
      ),
    );
    $form[$node->nid]['remove'] = array('#value' => l(t('remove'), '', $attr));
  }

  // add a textfield for adding nodes to the queue
  $form['add'] = array(
    '#type'   => 'markup',
  );
  $form['add']['nid'] = array(
    '#type' => 'textfield',
    '#autocomplete_path' => 'nodequeue/autocomplete/'. $subqueue->sqid,
    '#default_value' => t('Enter the title of a node to add it to the queue'),
  );
  $form['add']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Add node & save queue'),
    '#submit' => array('nodequeue_arrange_subqueue_form_add_submit'),
  );

  // add submit, reverse, shuffle, and clear buttons
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save')
  );
  $form['reverse'] = array(
    '#type' => 'submit',
    '#value' => t('Reverse'),
    '#submit' => array('nodequeue_arrange_subqueue_form_reverse_submit'),
  );
  $form['shuffle'] = array(
    '#type' => 'submit',
    '#value' => t('Shuffle'),
    '#submit' => array('nodequeue_arrange_subqueue_form_shuffle_submit'),
  );
  $form['clear'] = array(
    '#type' => 'submit',
    '#value' => t('Clear'),
    '#submit' => array('nodequeue_arrange_subqueue_form_clear_submit'),
  );
  $form['#validate'][] = 'nodequeue_arrange_subqueue_form_add_validate';
  // disable all buttons if the queue is empty
  if ($count == 0) {
    $form['submit']['#disabled']  = TRUE;
    $form['reverse']['#disabled'] = TRUE;
    $form['shuffle']['#disabled'] = TRUE;
    $form['clear']['#disabled']   = TRUE;
  }

  return $form;
}

/**
 * Validate handler for nodequeue_arrange_subqueue_form.
 */
function nodequeue_arrange_subqueue_form_validate($form, &$form_state) {
  $positions = array();
  foreach ($form_state['values'] as $nid => $element) {
    if (is_numeric($nid) && is_numeric($element['position'])) {
      $positions[$nid] = $element['position'];
    }
  }
  if (count(array_unique($positions)) < count($positions)) {
    $seen = array();
    foreach ($positions as $nid => $position) {
      if (isset($seen[$position])) {
        form_set_error($nid .'][position', t('Duplicate position value.'));
      }
      $seen[$position] = TRUE;
    }
  }
}

/**
 * Submit function for nodequeue_arrange_subqueue_form on 'Reverse' button.
 *
 * Yeah, this just calls the below function with a different parameter, but in D6 we're not supposed to use the $form['ops'].
 */
function nodequeue_arrange_subqueue_form_reverse_submit($form, &$form_state) {
  nodequeue_arrange_subqueue_form_submit($form, $form_state, TRUE, FALSE);
}

function nodequeue_arrange_subqueue_form_shuffle_submit($form, &$form_state) {
  nodequeue_arrange_subqueue_form_submit($form, $form_state, FALSE, TRUE);
}

/**
 * Submit handler for nodequeue drag'n'drop form. Updates node positions in {nodequeue_nodes}.
 */
function nodequeue_arrange_subqueue_form_submit($form, &$form_state, $reverse = FALSE, $shuffle = FALSE) {
  $nodes = array();
  foreach ($form_state['values'] as $nid => $element) {
    if (is_numeric($nid)) {
      $nodes[$form_state['values'][$nid]['position']] = $nid;
    }
  }

  $message = t('The queue has been updated.');

  if ($reverse || $shuffle) {
    $keys = array_keys($nodes);
    $values = array_values($nodes);

    // reverse the list if the reverse button was pressed
    if ($reverse) {
      $values = array_reverse($values);
      $message = t('The queue has been reversed.');
    }

    // shuffle the list if the shuffle button was pressed.
    if ($shuffle) {
      shuffle($values);
      $message = t('The queue has been shuffled.');
    }

    $nodes = array_combine($keys, $values);
  }

  $qid  = $form['#queue']['qid'];
  $sqid = $form['#subqueue']['sqid'];
  nodequeue_save_subqueue_order($nodes, $qid, $sqid);

  drupal_set_message($message);
}

/**
 * Validates new subqueue order information and if it passes validation,
 * deletes the old subqueue data from the database and saves the new data.
 *
 * @param $nodes:
 *   an array of nodes, keyed on the subqueue position.
 * @param $qid
 *   the queue id
 * @param unknown_type $sqid
 *   the subqueue id
 * @return An array where the first element is a numeric status code
 *   (0 means successfully saved) and the second element is a status message.
 */
function nodequeue_save_subqueue_order($nodes, $qid, $sqid) {
  $positions = array();
  $now = time();

  $queue = nodequeue_load($qid);
  $subqueue = nodequeue_load_subqueue($sqid);

  // cleanup the node array
  $clean = array();
  $count = 1;
  ksort($nodes);
  foreach ($nodes as $pos => $nid) {
    if (!is_numeric($nid) || $nid < 1) {
      return array(NODEQUEUE_INVALID_NID, 'Invalid nid value. New subqueue order not saved.');
    }
    if (is_numeric($pos)) {
      $clean[$count] = $nid;
      $count++;
    }
    else if ($pos == 'r') {
      // call nodequeue_remove hook
      module_invoke_all('nodequeue_remove', $sqid, $nid);
    }
    else {
      return array(NODEQUEUE_INVALID_POSITION, 'Invalid position value. New subqueue order not saved.');
    }
  }
  $nodes = $clean;

  if (count(array_unique($nodes)) < count($nodes)) {
    return array(NODEQUEUE_DUPLICATE_POSITION, 'Duplicate position values are not allowed. New subqueue order not saved.');
  }

  // clear the queue and save the new positions
  db_query('DELETE FROM {nodequeue_nodes} WHERE sqid = %d', $sqid);
  foreach ($nodes as $pos => $nid) {
    $args = array();
    if ($pos != 'r') {
      $positions[] = $pos;
      $placeholders = ' (%d, %d, %d, %d, %d)';
      $args = array($sqid, $qid, $nid, $pos, $now);
    }

    if (!empty($args)) {
      $sql = 'INSERT INTO {nodequeue_nodes} (sqid, qid, nid, position, timestamp) VALUES '. $placeholders;
      db_query($sql, $args);
    }
  }

  if ($queue->size) {
    // only necessary if the subqueue is of finite length
    nodequeue_check_subqueue_size($queue, $subqueue);
  }

  return array(NODEQUEUE_OK, 'The queue has been updated.');
}

function nodequeue_arrange_subqueue_form_clear_submit($form, &$form_state) {
  $form_state['redirect'] = 'admin/content/nodequeue/'. $form['#queue']['qid'] .'/clear/'. $form['#subqueue']['sqid'];
}

function nodequeue_arrange_subqueue_form_add_submit($form, &$form_state) {
  $queue = nodequeue_load($form['#queue']['qid']);
  $subqueue = nodequeue_load_subqueue($form['#subqueue']['sqid']);
  if (!empty($form_state['values']['add']['nid'])) {
    preg_match('/\[nid: (\d+)\]$/', $form_state['values']['add']['nid'], $matches);
    $nid = $matches[1];
    if (empty($nid)) {
      form_set_error('', t('Please enter a valid node title.'));
    }
  }

  nodequeue_subqueue_add($queue, $subqueue, $nid);
}

/**
 * Page callback to remove an item from a queue. This will be used only
 * if javascript is disabled in the client, and is a fallback technique.
 * This differs from nodequeue_admin_remove_node in that it removes a
 * specific position, which is necessary in case a node is in a queue
 * multiple times.
 */
function nodequeue_admin_remove($queue, $subqueue, $pos) {
  if (!is_numeric($pos) || !is_object($subqueue) || !nodequeue_check_token($pos)) {
    return drupal_goto();
  }

  nodequeue_subqueue_remove($subqueue, $pos);

  drupal_goto();
}

/**
 * Confirm form to clear a queue.
 */
function nodequeue_clear_confirm(&$form_state, $queue, $subqueue) {
  if (empty($subqueue)) {
    return;
  }

  drupal_set_title(t("Nodequeue '@title'", array('@title' => $queue->title)));

  $form['qid']  = array('#type' => 'value', '#value' => $queue->qid);
  $form['sqid'] = array('#type' => 'value', '#value' => $subqueue->sqid);

  return confirm_form($form,
    t('Are you sure you want to clear the nodequeue %queue?', array('%queue' => nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue))),
    isset($_GET['destination']) ? $_GET['destination'] : 'admin/content/nodequeue/'. $queue->qid .'/view/'. $subqueue->sqid,
    t('This action will remove all nodes from the queue and cannot be undone.'),
    t('Clear'), t('Cancel')
  );
}

/**
 * Submit function for nodequeue clear confirm
 */
function nodequeue_clear_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    nodequeue_queue_clear($form_state['values']['sqid']);
    drupal_set_message(t('The queue has been cleared.'));
    $form_state['redirect'] = 'admin/content/nodequeue/'. $form_state['values']['qid'] .'/view/'. $form_state['values']['sqid'];
  }
}

/**
 * Page callback for autocomplete.
 */
function nodequeue_autocomplete($sqid = NULL, $string = NULL) {
  $matches = _nodequeue_autocomplete($sqid, $string);
  drupal_json(drupal_map_assoc($matches));
}

function _nodequeue_autocomplete($sqid, $string) {
  $output = array();

  if (!$sqid || !is_numeric($sqid) || !$string) {
    return $output;
  }

  $subqueue = nodequeue_load_subqueue($sqid);
  if (!$subqueue) {
    return $output;
  }

  $queue = nodequeue_load($subqueue->qid);
  if (!$queue) {
    return $output;
  }

  $nodes = nodequeue_api_autocomplete($queue, $subqueue, $string);
  return $nodes;
}

/*
 * Get the list of nodes in the subqueue, taking into account node access restrictions.
 */
function nodequeue_nids_visible($sqid = -1, $account = NULL) {
  $node_status_sql = '';
  if (!$account) {
    global $user;
    $account = $user;
  }
  $nids_visible = array();
  if (!user_access('administer nodes', $account)) {
    $node_status_sql = ' AND (n.status = 1 || n.uid = %d)';
  }

  $query_restricted = db_query(db_rewrite_sql("SELECT DISTINCT(n.nid) FROM {node} n LEFT JOIN {nodequeue_nodes} nq ON nq.nid = n.nid WHERE nq.sqid = %d $node_status_sql ORDER BY nq.position ASC"), $sqid, $account->uid);
  while ($result_restricted = db_fetch_object($query_restricted)) {
    $nids_visible[$result_restricted->nid] = $result_restricted->nid;
  }
  return $nids_visible;
}
// --------------------------------------------------------------------------
// Nodequeue manipulation API.

/**
 * @defgroup nodequeue_api
 * @{
 * Access to the internals of nodequeues are handled primarily through these
 * API functions. They allow easy loading of queues for manipulation.
 */

/**
 * The nodequeue queue class; the constructor makes it so we don't have to
 * always check to see if our variables are empty or not.
 */
class nodequeue_queue {
  var $title = '';
  var $size = 0;
  var $link = '';
  var $link_remove = '';
  var $roles = array();
  var $types = array();
  var $show_in_links = TRUE;
  var $show_in_tab = TRUE;
  var $show_in_ui = TRUE;
  var $reference = 0;
  var $i18n = 1;

  var $subqueue_title = '';
  var $reverse = FALSE;

  // runtime
  var $subqueues = array();
  var $subqueue = NULL;

  var $current = NULL;

  function nodequeue_queue($type) {
    $this->owner = $type;
  }
}

/**
 * Return TRUE If the specified account has access to manipulate this queue.
 */
function nodequeue_queue_access($queue, $subqueue = NULL, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  // Automatically true if all queues.
  if (user_access('manipulate all queues', $account)) {
    return TRUE;
  }

  // Automatically false if they can't manipulate queues at all.
  if (!user_access('manipulate queues', $account) || empty($queue->roles)) {
    return FALSE;
  }

  if ($subqueue) {
    return nodequeue_api_subqueue_access($subqueue, $account);
  }

  if (!nodequeue_api_queue_access($queue, $account)) {
    return FALSE;
  }

  $roles = array_keys((array) $account->roles) + array(DRUPAL_AUTHENTICATED_RID);
  return (bool) array_intersect($roles, $queue->roles);
}

/**
 * Fetch a list of available queues for a given location. These queues
 * will be fully loaded and ready to go.
 */
function nodequeue_load_queues_by_type($type, $location = NULL, $account = NULL, $bypass_cache = FALSE) {
  $qids = nodequeue_get_qids($type, $account, $bypass_cache);
  if ($location) {
    nodequeue_filter_qids($qids, $location);
  }
  return nodequeue_load_queues(array_keys($qids), $bypass_cache);
}

/**
 * Used by menu system to determine access to the node and the queue in question.
 *
 * No, this isn't some odd hook_access implementation.
 *
 * @param unknown_type $node
 * @param unknown_type $queue
 * @return unknown
 */
function nodequeue_node_and_queue_access($node, $queue, $subqueue = NULL) {
  return nodequeue_node_access($node->type) && nodequeue_queue_access($queue, $subqueue);
}

function nodequeue_node_tab_access($node) {
  if (!user_access('manipulate queues')) {
    //For performance reasons: If the user can't manipulate queues, there is no reason to run the rest of these queries.
    return FALSE;
  }
  $queues = nodequeue_load_queues_by_type($node->type, 'tab');
  $subqueues = nodequeue_get_subqueues_by_node($queues, $node);
  if (empty($subqueues)) {
    return FALSE;
  }
  foreach ($subqueues as $subqueue) {
    if (!nodequeue_api_subqueue_access($subqueue)) {
      unset($subqueues[$subqueue->sqid]);
    }
  }
  return (variable_get('nodequeue_use_tab', 1) && !empty($subqueues));
}
/**
 * Return TRUE if $user can queue(s) for this node.
 *
 * @param $type
 *   The node type.
 * @param $location
 *   Optional argument. May be one of:
 *   - 'links': Only check for queues that have node links.
 *   - 'tab': Only check for queues that appear on the node tab.
 *   - 'ui': Only check for queues that appear in the UI.
 */
function nodequeue_node_access($type, $location = NULL, $account = NULL) {
  $qids = nodequeue_get_qids($type, $account);
  if ($location) {
    nodequeue_filter_qids($qids, $location);
  }

  return !empty($qids);
}

/**
 * Filter a list of qids returned by nodequeue_get_qids to a location.
 *
 * @param $qids
 *   An array of $qids from @see nodequeue_get_qids()
 * @param $location
 *   One of:
 *   - 'links': Only check for queues that have node links.
 *   - 'tab': Only check for queues that appear on the node tab.
 *   - 'ui': Only check for queues that appear in the UI.
 */
function nodequeue_filter_qids(&$qids, $location) {
  $var = "show_in_$location";
  foreach ($qids as $qid => $info) {
    if (empty($info->$var)) {
      unset($qids[$qid]);
    }
  }
}

/**
 * Get an array of qids applicable to this node type.
 *
 * @param $type
 *   The node type.
 * @param $account
 *   The account to test against. Defaults to the currently logged in user.
 *
 * @return $qids
 *   An array in the format: @code { array($qid => array('qid' => $qid, 'show_in_tab' '
 *   => true/false, 'show_in_links' => true/false }
 *
 * @param $bypass_cache
 *  Boolean value indicating whether to bypass the cache or not.
 */
function nodequeue_get_qids($type, $account = NULL, $bypass_cache = FALSE) {
  if (!isset($account)) {
    global $user;
    $account = $user;
  }

  static $cache = array();
  if ($bypass_cache || !isset($cache[$type])) {
    $roles_join = $roles_where = '';
    $roles = array();

    // superuser always has access.
    if (!user_access('manipulate all queues', $account)) {
      $roles_join = "INNER JOIN {nodequeue_roles} nr ON nr.qid = nq.qid ";
      $roles = array_keys((array) $account->roles) + array(DRUPAL_AUTHENTICATED_RID);

      $roles_where .= "AND nr.rid IN (". db_placeholders($roles, 'int') .")";
    }

    $sql = 'SELECT nq.qid, nq.show_in_tab, nq.show_in_links, nq.show_in_ui, nq.i18n '.
      'FROM {nodequeue_queue} nq '.
      'INNER JOIN {nodequeue_types} nt ON nt.qid = nq.qid '. $roles_join .
      "WHERE nt.type = '%s' ". $roles_where;
    $result = db_query($sql, array_merge(array($type), $roles));

    $qids = array();
    while ($qid = db_fetch_object($result)) {
      $qids[$qid->qid] = $qid;
    }
    $cache[$type] = $qids;
  }
  return $cache[$type];
}

/**
 * Get an array all qids using the pager query. This administrative list
 * does no permission checking, so should only be available to users who
 * have passed the 'administer queues' check.
 *
 * @param $page_size
 *   The page size to use. If 0 will be all queues.
 * @param $pager_element
 *   In the rare event this should use another pager element, set this..
 *
 * @return $qids
 *   An array in the format: @code { array($qid => array('qid' => $qid, 'show_in_tab' '
 *    => true/false, 'show_in_links' => true/false }
 * @param $bypass_cache
 *   Boolean value indicating whether to bypass the cache or not.
 */
function nodequeue_get_all_qids($page_size = 25, $pager_element = 0, $bypass_cache = FALSE) {
  static $cache = NULL;
  if ($bypass_cache || !isset($cache)) {
    $sql = 'SELECT nq.qid '.
           'FROM {nodequeue_queue} nq '.
           'WHERE nq.show_in_ui = 1 ';
    $count_sql = 'SELECT COUNT(q.qid) FROM {nodequeue_queue} q WHERE q.show_in_ui = 1 ';
    if ($page_size) {
      $result = pager_query($sql, $page_size, $pager_element, $count_sql);
    }
    else {
      $result = db_query($sql, $count_sql);
    }

    $qids = array();
    while ($qid = db_fetch_object($result)) {
      $qids[$qid->qid] = $qid->qid;
    }
    $cache = $qids;
  }
  return $cache;
}

/**
 * Load an array of $qids.
 *
 * This exists to provide a way of loading a bunch of queues with
 * the fewest queries. Loading 5 queues results in only 4 queries,
 * not 20. This also caches queues so that they don't get loaded
 * repeatedly.
 *
 * @param $qids
 *   An array of queue IDs to load.
 *
 * @param $bypass_cache
 *   Boolean value indicating whether to bypass the cache or not.
 */
function nodequeue_load_queues($qids = array(), $bypass_cache = FALSE) {
  static $cache = array();
  $to_load = $loaded = array();

  foreach ($qids as $qid) {
    if ($bypass_cache || !isset($cache[$qid])) {
      $to_load[] = $qid;
    }
  }

  if (!empty($to_load)) {
    $placeholders = db_placeholders($to_load, 'int');
    $result = db_query("SELECT q.*, COUNT(s.sqid) AS subqueues FROM {nodequeue_queue} q LEFT JOIN {nodequeue_subqueue} s ON q.qid = s.qid WHERE q.qid IN ($placeholders) GROUP BY q.qid", $to_load);
    while ($queue = db_fetch_object($result)) {
      $loaded[$queue->qid] = $queue;
      // ensure valid defaults:
      $loaded[$queue->qid]->types = array();
      $loaded[$queue->qid]->roles = array();
      $loaded[$queue->qid]->count = 0;
    }

    $result = db_query("SELECT qid, rid FROM {nodequeue_roles} WHERE qid IN ($placeholders)", $to_load);
    while ($obj = db_fetch_object($result)) {
      $loaded[$obj->qid]->roles[] = $obj->rid;
    }

    $result = db_query("SELECT qid, type FROM {nodequeue_types} WHERE qid IN ($placeholders)", $to_load);
    while ($obj = db_fetch_object($result)) {
      $loaded[$obj->qid]->types[] = $obj->type;
    }

    drupal_alter('nodequeue', $loaded, 'load_queues');
  }

  if ($bypass_cache) {
    return $loaded;
  }
  else {
    if (!empty($loaded)) {
      $cache += $loaded;
    }
    $queues = array();
    foreach ($qids as $qid) {
      if (isset($cache[$qid])) {
        $queues[$qid] = $cache[$qid];
      }
    }
    return $queues;
  }
}

/**
 * Load a nodequeue.
 *
 * @param $qid
 *   The qid of the queue to load.
 */
function nodequeue_load($qid) {
  $queues = nodequeue_load_queues(array($qid));
  return !empty($queues) ? array_shift($queues) : array();
}

/**
 * This function exists so that %subqueue will work in hook_menu.
 */
function subqueue_load($sqid) {
  if (!$sqid) {
    return NULL;
  }
  return array_shift(nodequeue_load_subqueues(array($sqid)));
}

/**
 * Load a list of subqueues
 *
 * This exists to provide a way of loading a bunch of queues with
 * the fewest queries. Loading 5 queues results in only 4 queries,
 * not 20. This also caches queues so that they don't get loaded
 * repeatedly.
 *
 * @param $sqids
 *   An array of subqueue IDs to load.
 * @param $bypass_cache
 *   Boolean value indicating whether to bypass the cache or not.
 */
function nodequeue_load_subqueues($sqids, $bypass_cache = FALSE) {
  static $cache = array();
  $to_load = array();

  foreach ($sqids as $sqid) {
    if ($bypass_cache || !isset($cache[$sqid])) {
      $to_load[] = $sqid;
    }
  }

  if (!empty($to_load)) {
    $placeholders = db_placeholders($to_load, 'int');

    $result = db_query("SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE s.sqid IN ($placeholders) GROUP BY s.sqid", $to_load);
    while ($obj = db_fetch_object($result)) {
      // Sometimes we want to get to subqueues by reference, sometimes by sqid.
      // sqid is always unique, but reference is sometimes more readily available.
      $cache[$obj->sqid] = $obj;
    }
  }

  foreach ($sqids as $sqid) {
    if (isset($cache[$sqid])) {
      $subqueues[$sqid] = $cache[$sqid];
    }
  }
  return $subqueues;
}

/**
 * Load a single subqueue.
 *
 * @param $sqid
 *   The subqueue ID to load.
 * @param $bypass_cache
 *   Boolean value indicating whether to bypass the cache or not.
 */
function nodequeue_load_subqueue($sqid, $bypass_cache = FALSE) {
  $subqueues = nodequeue_load_subqueues(array($sqid), $bypass_cache);
  if ($subqueues) {
    return array_shift($subqueues);
  }

}

/**
 * Load the entire set of subqueues for a queue.
 *
 * This will load the entire set of subqueues for a given queue (and can
 * respect the pager, if desired). It does NOT cache the subqueues like
 * nodequeue_load_subqueues does, so beware of this mixed caching.
 *
 * @param $qids
 *   A $qid or array of $qids
 * @param $page_size
 *   If non-zero, use the pager_query and limit the page-size to the parameter.
 */
function nodequeue_load_subqueues_by_queue($qids, $page_size = 0) {
  if (is_numeric($qids)) {
    $qids = array($qids);
  }

  if (empty($qids)) {
    return array();
  }

  $query = "SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE s.qid IN (". db_placeholders($qids, 'int') .") GROUP BY s.sqid";
  if ($page_size) {
    $result = pager_query($query, $page_size, 0, $qids);
  }
  else {
    $result = db_query($query, $qids);
  }

  $subqueues = array();

  while ($subqueue = db_fetch_object($result)) {
    $subqueues[$subqueue->sqid] = $subqueue;
  }

  return $subqueues;
}

/**
 * Load a set of subqueues by reference.
 *
 * This can be used to load a set of subqueues by reference; it will primarily
 * be used by plugins that are managing subqueues.
 *
 * @param $references
 *   A keyed array of references to load. The key is the $qid and each value
 *   is another array of references.
 */
function nodequeue_load_subqueues_by_reference($references, $bypass_cache = FALSE) {
  static $cache = array();
  $subqueues = array();
  if ($bypass_cache) {
    $cache = array();
  }

  // build strings for the query based upon the qids and references.
  $keys = $values = array();
  foreach ($references as $qid => $qid_references) {
    $keys[$qid] = array();
    $qid_values = array();
    foreach ($qid_references as $reference) {
      // If we already have this qid/reference combo cached, don't add it to
      // our little list.
      if (isset($cache[$qid][$reference])) {
        $subqueues[$cache[$qid][$reference]->sqid] = $cache[$qid][$reference];
      }
      else {
        $keys[$qid][] = "'%s'"; // Substitution strings
        $qid_values[] = $reference; // Values to substitute
      }
    }
    if (!empty($keys[$qid])) {
      $values = array_merge($values, array($qid), $qid_values);
    }
    else {
      unset($keys[$qid]);
    }
  }

  if (!empty($keys)) {
    $where = '';
    foreach ($keys as $key_list) {
      if ($where) {
        $where .= ' OR ';
      }
      $where .= 's.qid = %d AND s.reference IN ('. implode(', ', $key_list) .')';
    }

    $result = db_query("SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE $where GROUP BY s.sqid", $values);

    while ($subqueue = db_fetch_object($result)) {
      $cache[$subqueue->qid][$subqueue->reference] = $subqueues[$subqueue->sqid] = $subqueue;
    }
  }

  return $subqueues;
}

/**
 * Save a nodequeue. This does not save subqueues; those must be added separately.
 */
function nodequeue_save(&$queue) {
  if (!isset($queue->qid)) {
    db_query("INSERT INTO {nodequeue_queue} (title, subqueue_title, size, link, link_remove, owner, show_in_links, show_in_tab, show_in_ui, i18n, reverse, reference) VALUES ('%s', '%s', %d, '%s', '%s', '%s', %d, %d, %d, %d, %d, '%s')", $queue->title, $queue->subqueue_title, $queue->size, $queue->link, $queue->link_remove, $queue->owner, $queue->show_in_links, $queue->show_in_tab, $queue->show_in_ui, $queue->i18n, $queue->reverse, $queue->reference);
    $queue->qid = db_last_insert_id('nodequeue_queue', 'qid');
    if (function_exists('views_invalidate_cache')) {
      views_invalidate_cache();
    }
  }
  else {
    db_query("UPDATE {nodequeue_queue} set size = %d, title = '%s', subqueue_title = '%s', link = '%s', link_remove = '%s', owner = '%s', show_in_links = %d, show_in_tab = %d, show_in_ui = %d, i18n = %d, reverse = %d, reference = '%s' WHERE qid = %d", $queue->size, $queue->title, $queue->subqueue_title, $queue->link, $queue->link_remove, $queue->owner, $queue->show_in_links, $queue->show_in_tab, $queue->show_in_ui, $queue->i18n, $queue->reverse, $queue->reference, $queue->qid);
    db_query("DELETE FROM {nodequeue_roles} WHERE qid = %d", $queue->qid);
    db_query("DELETE FROM {nodequeue_types} WHERE qid = %d", $queue->qid);
  }

  if (is_array($queue->roles)) {
    foreach ($queue->roles as $rid)
      db_query("INSERT INTO {nodequeue_roles} (qid, rid) VALUES (%d, %d)", $queue->qid, $rid);
  }

  if (is_array($queue->types)) {
    foreach ($queue->types as $type)
      db_query("INSERT INTO {nodequeue_types} (qid, type) VALUES (%d, '%s')", $queue->qid, $type);
  }

  // set our global that tells us whether or not we need to activate hook_link
  if (db_result(db_query("SELECT COUNT(*) FROM {nodequeue_queue} WHERE link <> ''"))) {
    variable_set('nodequeue_links', TRUE);
  }
  else {
    variable_set('nodequeue_links', FALSE);
  }

  if (isset($queue->add_subqueue) && is_array($queue->add_subqueue)) {
    foreach ($queue->add_subqueue as $reference => $title) {
      // If reference is unset it should be set to the qid; this is generally
      // used for a single subqueue; setting the reference to the qid makes
      // it easy to find that one subqueue.
      if ($reference == 0) {
        $reference = $queue->qid;
      }
      nodequeue_add_subqueue($queue, $title, $reference);
    }
  }
  return $queue->qid;
}

/**
 * Delete a nodequeue.
 */
function nodequeue_delete($qid) {
  db_query("DELETE FROM {nodequeue_queue} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_roles} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_types} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_nodes} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_subqueue} WHERE qid = %d", $qid);
}

/**
 * Add a new subqueue to a queue.
 *
 * @param $qid
 *   The queue id. This should not be the full queue object.
 * @param $reference
 *   A reference that uniquely identifies this subqueue. If NULL it will
 *   be assigned to the sqid.
 */
function nodequeue_add_subqueue(&$queue, $title, $reference = NULL) {
  if (empty($reference)) {
    $insert_reference = "";
  }
  else {
    $insert_reference = $reference;
  }

  $subqueue = new stdClass();;
  $subqueue->reference = $reference;
  $subqueue->qid = $queue->qid;
  $subqueue->title = $title;

  db_query("INSERT INTO {nodequeue_subqueue} (qid, reference, title) VALUES (%d, '%s', '%s')", $queue->qid, $insert_reference, $title);

  $subqueue->sqid = db_last_insert_id('nodequeue_subqueue', 'sqid');

  // If somehow the $reference is null, here we set it to the sqid.
  // We have to do it here, because before the insert we don't know what the sqid will be.
  if (empty($reference)) {
    db_query("UPDATE {nodequeue_subqueue} SET reference = '%s' WHERE sqid = %d", $subqueue->sqid, $subqueue->sqid);
  }

  return $subqueue;
}

/**
 * Change the title of a subqueue.
 *
 * Note that only the title of a subqueue is changeable; it can change to
 * reflect updates in taxonomy term names, for example.
 */
function nodequeue_subqueue_update_title($sqid, $title) {
  db_query("UPDATE {nodequeue_subqueue} SET title = '%s' WHERE sqid = %d", $title, $sqid);
}

/**
 * Remove a subqueue.
 */
function nodequeue_remove_subqueue($sqid) {
  nodequeue_queue_clear($sqid);
  db_query("DELETE FROM {nodequeue_subqueue} WHERE sqid = %d", $sqid);
}

// --------------------------------------------------------------------------
// Queue position control

/**
 * Add a node to a queue.
 *
 * @param $queue
 *   The parent queue of the subqueue. This is required so that we can
 *   pop nodes out if the queue breaks size limits.
 * @param $sqid
 *   The subqueue ID to add the node to.
 * @param $nid
 *   The node ID
 */
function nodequeue_subqueue_add($queue, &$subqueue, $nid) {
  if (!empty($nid)) {
    db_query("INSERT INTO {nodequeue_nodes} (sqid, qid, nid, position, timestamp) VALUES (%d, %d, %d, %d, %d)", $subqueue->sqid, $queue->qid, $nid, $subqueue->count + 1, time());
    $subqueue->count++;
    // If adding this would make the queue too big, pop the front node
    // (or nodes) out.
    if (!empty($queue->size)) {
      // 0 means infinity so never do this if false
      nodequeue_check_subqueue_size($queue, $subqueue, $queue->size);
    }
    if (module_exists('apachesolr')) {
      apachesolr_mark_node($nid);
    }  
    //Invoke the hook to notify other modules of the node addition.
    module_invoke_all('nodequeue_add', $subqueue->sqid, $nid);
  }
}

/**
 * Remove a node from the queue. If a node is in the queue more than once,
 * only the first (closest to 0 position, or the front of the queue) will
 * be removed.
 *
 * @param $sqid
 *   The subqueue to remove nodes from.
 * @param $nid
 *   The node to remove.
 */
function nodequeue_subqueue_remove_node($sqid, $nid) {
  if ($pos = nodequeue_get_subqueue_position($sqid, $nid)) {
    nodequeue_subqueue_remove($sqid, $pos);
    if (module_exists('apachesolr')) {
      apachesolr_mark_node($nid);
    }

    // Invoke the hook to notify other modules of the node removal.
    module_invoke_all('nodequeue_remove', $sqid, $nid);
  }
}
/**
 * Remove a node or node(s) from a nodequeue by position.
 *
 * If you know the nid but but not the position, use
 * @see nodequeue_subqueue_remove_node() instead.
 *
 * @param $sqid
 *   The subqueue to remove nodes from.
 * @param $start
 *   The first position (starting from 1) to remove.
 * @param $end
 *   The last position to remove. If NULL or equal to $start,
 *   only one node will be removed. Thus if $start is 1 and $end is 2,
 *   the first and second items will be removed from the queue.
 *
 */
function nodequeue_subqueue_remove($sqid, $start, $end = NULL) {
  if (!isset($end)) {
    $end = $start;
  }

  // Retrieve the nodes that are being removed.
  $result = db_query("SELECT nid FROM {nodequeue_nodes} WHERE sqid = %d AND position >= %d AND position <= %d", $sqid, $start, $end);

  $diff = $end - $start + 1;
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position >= %d AND position <= %d", $sqid, $start, $end);
  db_query("UPDATE {nodequeue_nodes} SET position = position - %d WHERE sqid = %d AND position > %d",  $diff, $sqid, $end);
  
  // Invoke the hook to let other modules know that the nodes were removed.
  while($node = db_fetch_object($result)) {
    module_invoke_all('nodequeue_remove', $sqid, $node->nid);
  }
}

/**
 * Empty a subqueue.
 *
 * @param $sqid
 *   The sqid to empty.
 */
function nodequeue_queue_clear($sqid) {
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d", $sqid);
}

/**
 * Guarantee that a subqueue has not gotten too big. It's important to call
 * this after an operation that might have reduced a queue's maximum size.
 * It stores the count to save a query if this is to be followed by an add
 * operation.
 *
 * @param $queue
 *   The queue object.
 * @param $reference
 *   The subqueue to check.
 *
 */
function nodequeue_check_subqueue_size($queue, &$subqueue, $size = NULL) {
  if (!isset($size)) {
    $size = $queue->size;
  }

  if ($queue->size && $subqueue->count > $size) {
    nodequeue_subqueue_remove($subqueue->sqid, 1, $subqueue->count - $size);
    $subqueue->count = $size;
  }
}

/**
 * Guarantee that all subqueues are within the size constraints set
 * by $queue->size.
 */
function nodequeue_check_subqueue_sizes($queue) {
  // Don't check if size is 0, as that means infinite size.
  if (!$queue->size) {
    return;
  }

  $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);
  foreach ($subqueues as $subqueue) {
    nodequeue_check_subqueue_size($queue, $subqueue);
  }
}

/**
 * Swap two positions within a subqueue.
 */
function nodequeue_queue_swap($subqueue, $pos1, $pos2) {
  // Grab the nid off one of the positions so we can more easily swap.
  $nid = db_result(db_query("SELECT nid FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $pos1));
  if (!$nid) {
    return;
  }

  db_query("UPDATE {nodequeue_nodes} SET position = %d WHERE position = %d AND sqid = %d", $pos1, $pos2,  $subqueue->sqid);
  db_query("UPDATE {nodequeue_nodes} SET position = %d WHERE nid = %d AND sqid = %d", $pos2, $nid, $subqueue->sqid);

  // notify other modules of the swap
  module_invoke_all('nodequeue_swap', $sqid, $nid);

}

/**
 * Move a position within a subqueue up by one.
 */
function nodequeue_queue_up($subqueue, $position) {
  if ($position < 2 || $position > $subqueue->count)
    return;
  nodequeue_queue_swap($subqueue, $position - 1, $position);
}

/**
 * Move a position within a subqueue down by one.
 */
function nodequeue_queue_down($subqueue, $position) {
  if ($position < 1 || $position >= $subqueue->count)
    return;
  nodequeue_queue_swap($subqueue, $position + 1, $position);
}

/**
 * Move an item to the front of the queue.
 */
function nodequeue_queue_front($subqueue, $position) {
  if ($position < 2 || $position > $subqueue->count)
    return;
  $entry = db_fetch_object(db_query("SELECT * FROM {nodequeue_nodes} WHERE sqid= %d AND position = %d", $subqueue->sqid, $position));
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position);
  db_query("UPDATE {nodequeue_nodes} SET position = position + 1 WHERE sqid= %d AND position < %d", $subqueue->sqid, $position);
  db_query("INSERT INTO {nodequeue_nodes} (qid, sqid, nid, position, timestamp) VALUES (%d, %d, %d, 1, %d)", $entry->qid, $subqueue->sqid, $entry->nid, $entry->timestamp);
}

/**
 * Move an item to the back of the queue.
 */
function nodequeue_queue_back($subqueue, $position) {
  if ($position < 1 || $position >= $subqueue->count)
    return;
  $entry = db_fetch_object(db_query("SELECT * FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position));
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position);
  db_query("UPDATE {nodequeue_nodes} SET position = position - 1 WHERE sqid = %d AND position > %d", $subqueue->sqid, $position);
  db_query("INSERT INTO {nodequeue_nodes} (qid, sqid, nid, position, timestamp) VALUES (%d, %d, %d, %d, %d)", $entry->qid, $subqueue->sqid, $entry->nid, $subqueue->count, $entry->timestamp);
}

/**
 * Get the position of a node in a subqueue, or 0 if not found.
 */
function nodequeue_get_subqueue_position($sqid, $nid) {
  // We use MIN to make sure we always get the closes to the front of the
  // queue in case the queue has nodes in it multiple times.
  $pos = db_result(db_query("SELECT MIN(position) FROM {nodequeue_nodes} WHERE sqid = %d AND nid = %d", $sqid, $nid));
  return $pos;
}

/**
 * Get the position of a node in several subqueues.
 */
function nodequeue_set_subqueue_positions(&$subqueues, $nid) {
  if (empty($subqueues)) {
    return;
  }
  $placeholders = db_placeholders($subqueues, 'int');
  $args = array_keys($subqueues);
  $args[] = $nid;
  $result = db_query("SELECT sqid, MIN(position) AS position FROM {nodequeue_nodes} WHERE sqid IN ($placeholders) AND nid = %d GROUP BY sqid", $args);
  while ($obj = db_fetch_object($result)) {
    $subqueues[$obj->sqid]->position = $obj->position;
  }
}

/**
 * Get a list of valid subqueues for a node, along with the position of the node.
 *
 * @param $queues
 *   An array of fully loaded queue objects.
 * @param $node
 *   A fully loaded node object.
 *
 */
function nodequeue_get_subqueues_by_node($queues, $node) {
  // Determine which subqueues are valid for each queue.
  $references= array();
  static $last_nid = 0;
  foreach ($queues as $queue) {
    if ($result = nodequeue_api_subqueues($queue, $node)) {
      $references[$queue->qid] = is_array($result) ? $result : array($result);
    }
  }

  if (empty($references)) {
    return array();
  }
  // only allow the static cache to be used if the nid is the same as the last
  $subqueues = nodequeue_load_subqueues_by_reference($references, ($last_nid != $node->nid));
  $last_nid = $node->nid;

  return $subqueues;
}

/**
 * Get a textual representation of a nodequeue's queue size.
 */
function nodequeue_subqueue_size_text($max, $count, $long = TRUE) {
  if (empty($count)) {
    $message = theme('nodequeue_subqueue_empty_text');
  }
  else if ($count == $max) {
    $message = theme('nodequeue_subqueue_full_text');
  }
  else {
    if ($long) {
      $message = theme('nodequeue_subqueue_count_text', $count);
    }
    else {
      $message = $count;
    }
  }
  return $message;
}

/**
 * Substitute the subqueue title into some other string.
 *
 * This function does NOT check_plain the title! The output MUST be checked
 * after this is complete.
 */
function nodequeue_title_substitute($text, $queue, $subqueue) {
  if (empty($text)) {
    return $subqueue->title;
  }
  $text = str_replace('%subqueue', $subqueue->title, $text);
  return $text;
}

/**
 * Shuffle a queue.
 *
 * @param $subqueue
 *   The subqueue to shuffle. May be a sqid or the loaded object.
 */
function nodequeue_subqueue_shuffle($subqueue) {
  // Load the queue
  if (!is_object($subqueue)) {
    $subqueue = nodequeue_load_subqueue($subqueue);
  }

  if (empty($subqueue)) {
    return;
  }

  $count = $subqueue->count;
  // Swap each item with another randomly picked one.
  foreach (range(1, $count) as $i) {
    nodequeue_queue_swap($subqueue, $i, rand(1, $count));
  }
}

/**
 * @} End of defgroup "nodequeue_api"
 */

// --------------------------------------------------------------------------
// Hooks to implement the default nodequeue type.

/**
 * Implementation of hook_nodequeue_info()
 */
function nodequeue_nodequeue_info() {
  return array('nodequeue' => array(
    'title' => t('Nodequeue'),
    'description' => t('Standard nodequeues have just one subqueue. Nodes put into a queue are added to the back of the queue; when a node is added to a full queue, the node in the front of the queue will be popped out to make room.'),
    ));
}

/**
 * Implementation of hook_nodequeue_form_submit()
 */
function nodequeue_nodequeue_form_submit(&$queue, $form_state) {
  // This will add a single subqueue to our new queue.
  if (!isset($queue->qid) && !isset($queue->add_subqueue)) {
    // A 0 will set the reference to the sqid of the queue.
    $queue->add_subqueue = array(0 => $queue->title);
  }
  //If the qid is set at this point, we're saving an existing queue.
  if (isset($queue->qid)) {
    //We don't check to see if the title has been updated since the $queue object already matches $form_state['values'].
    db_query("UPDATE {nodequeue_subqueue} SET title = '%s' WHERE qid = %d", array($form_state['values']['title'], $queue->qid));
  }
}

// --------------------------------------------------------------------------
// External queue fetching

/**
 * in general it's preferable to use Views for this functionality.
 */
function nodequeue_node_titles($sqid, $title = '', $backward = true, $from = 0, $count = 0, $published_only = TRUE) {
  $orderby = ($backward ? "DESC" : "ASC");
  if ($published_only) {
    $published_sql = 'AND n.status = 1';
  }
  $sql = db_rewrite_sql("SELECT n.nid, n.title FROM {node} n LEFT JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d $published_sql ORDER BY nn.position $orderby");
  if ($count) {
    $result = db_query_range($sql, $sqid, $from, $count);
  }
  else {
    $result = db_query($sql, $sqid);
  }
  return node_title_list($result, $title);
}

/**
 * Get node_view output from a nodequeue
 */
function nodequeue_view_nodes($sqid, $backward = TRUE, $teaser = TRUE, $links = TRUE, $from = 0, $count = 0) {
  $nodes = nodequeue_load_nodes($sqid, $backward, $from, $count);
  foreach ($nodes as $node) {
    $output .= node_view($node, $teaser, FALSE, $links);
  }
  return $output;
}

/**
 * Load an array of node objects belonging to a particular nodequeue.
 */
function nodequeue_load_nodes($sqid, $backward = FALSE, $from = 0, $count = 5, $published_only = TRUE) {
  $orderby = ($backward ? "DESC" : "ASC");
  if ($published_only) {
    $published_sql = 'AND n.status = 1';
  }
  $sql = db_rewrite_sql("SELECT n.nid FROM {node} n INNER JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d $published_sql ORDER BY nn.position $orderby");
  if ($count) {
    $result = db_query_range($sql, $sqid, $from, $count);
  }
  else {
    $result = db_query($sql, $sqid);
  }

  $nodes = array();
  while ($nid = db_fetch_object($result)) {
    $nodes[] = node_load($nid->nid);
  }

  return $nodes;
}

/**
 * Load the first node of a queue
 */
function nodequeue_load_front($sqid) {
  return array_shift(nodequeue_load_nodes($sqid, FALSE, 0, 1));
}

/**
 * Load the last node of a queue
 */
function nodequeue_load_back($sqid, $teaser = TRUE, $links = TRUE) {
  return array_shift(nodequeue_load_nodes($sqid, TRUE, 0, 1));
}

/**
 * View a random node from a queue
 */
function nodequeue_view_random_node($sqid, $teaser = TRUE, $links = TRUE) {
  $count = db_result(db_query(db_rewrite_sql("SELECT COUNT(n.nid) FROM {node} n INNER JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1"), $sqid));
  return nodequeue_view_nodes($sqid, FALSE, $teaser, $links, rand(0, $count - 1), 1);
}

/**
 * Load a random node object from a queue
 */
function nodequeue_load_random_node($sqid) {
  $count = db_result(db_query(db_rewrite_sql("SELECT COUNT(n.nid) FROM {node} n INNER JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1"), $sqid));
  return array_shift(nodequeue_load_nodes($sqid, TRUE, rand(0, $count - 1), 1));
}

/**
 * Get the position of a node in a subqueue, or FALSE if not found.
 */
function nodequeue_subqueue_position($sqid, $nid) {
  return db_result(db_query("SELECT position FROM {nodequeue_nodes} WHERE sqid = %d AND nid = %d", $sqid, $nid));
}

/**
 * Get the position of a node in a queue; this queue MUST have only one
 * subqueue or the results of this function will be unpredictable.
 */
function nodequeue_queue_position($qid, $nid) {
  $sqid = db_result(db_query_range("SELECT sqid FROM {nodequeue_subqueue} WHERE qid = %d", $qid, 0, 1));
  return nodequeue_subqueue_position($sqid, $nid);
}

// --------------------------------------------------------------------------
// API for modules implementing subqueues.

/**
 * Send the nodequeue edit form to the owning module for modification.
 *
 * @param $queue
 *   The queue being edited.
 * @param &$form
 *   The form. This may be modified.
 */
function nodequeue_api_queue_form($queue, &$form) {
  $function = $queue->owner ."_nodequeue_form";
  if (function_exists($function)) {
    $function($queue, $form);
  }
}

/**
 * Validate the nodequeue edit form.
 *
 * @param $queue
 *   The queue being edited.
 * @param $form_state
 *   The form values that were submitted.
 * @param &$form
 *   The actual form object. This may be modified.
 */
function nodequeue_api_queue_form_validate($queue, &$form_state, &$form) {
  $function = $queue->owner ."_nodequeue_form_validate";
  if (function_exists($function)) {
    $function($queue, $form_state, $form);
  }
}

/**
 * Send the nodequeue edit form to the owning module upon submit.
 *
 * @param &$queue
 *   The queue being edited. This may be modified prior to being
 *   saved.
 * @param $form_state
 *   The form values that were submitted.
 */
function nodequeue_api_queue_form_submit(&$queue, &$form_state) {
  $function = $queue->owner ."_nodequeue_form_submit";
  if (function_exists($function)) {
    $function($queue, $form_state);
  }
}

/**
 * Send the nodequeue edit form to the owning module after the queue
 * has been saved.
 *
 * @param &$queue
 *   The queue being edited. This may be modified prior to being
 *   saved.
 * @param $form_state
 *   The form values that were submitted.
 */
function nodequeue_api_queue_form_submit_finish($queue, &$form_state) {
  $function = $queue->owner ."_nodequeue_form_submit_finish";
  if (function_exists($function)) {
    $function($queue, $form_state);
  }
}

/**
 * Fetch a list of subqueues that are valid for this node from
 * the owning module.
 *
 * @param $queue
 *   The queue being edited.
 * @param $node
 *   The loaded node object being checked.
 *
 * @return
 *   An array of subqueues. This will be keyed by $sqid.
 */
function nodequeue_api_subqueues(&$queue, $node) {
  $function = $queue->owner ."_nodequeue_subqueues";
  // This will return an array of references.
  if (function_exists($function)) {
    return $function($queue, $node);
  }
  else {
    return $queue->qid;
  }
}

/**
 * Fetch a list of nodes available to a given subqueue
 * for autocomplete.
 *
 * @param $queue
 *   The queue that owns the subqueue
 * @param $subqueue
 *   The subqueue
 * @param $string
 *   The string being matched.
 *
 * @return
 *   An keyed array $nid => $title
 */
function nodequeue_api_autocomplete($queue, $subqueue, $string) {
  $matches = array();
  if (empty($string)) {
    return $matches;
  }
  $where_args = array();
  global $user;
  if (!user_access('administer nodes', $user)) {
    $where = '(n.status = 1 || n.uid = %d) AND ';
    $where_args = array($user->uid);
  }
  
  $where .= "n.type IN (". db_placeholders($queue->types, 'varchar') .')';
  $where_args = array_merge($where_args, $queue->types);

  // Run a match to see if they're specifying by nid.
  $preg_matches = array();
  $match = preg_match('/\[nid: (\d+)\]/', $string, $preg_matches);
  if (!$match) {
    $match = preg_match('/^nid: (\d+)/', $string, $preg_matches);
  }

  if ($match) {
    // If it found a nid via specification, reduce our resultset to just that nid.
    $where .= " AND n.nid = %d";
    array_push($where_args, $preg_matches[1]);
  }
  else {
    // Build the constant parts of the query.
    $where .= " AND LOWER(n.title) LIKE LOWER('%s%%')";
    array_push($where_args, $string);
  }

  // Call to the API.
  $function = $queue->owner ."_nodequeue_autocomplete";
  if (function_exists($function)) {
    return $function($queue, $subqueue, $string, $where, $where_args);
  }
  else {
    $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title FROM {node} n WHERE $where"), $where_args, 0, 10);
    while ($node = db_fetch_object($result)) {
      $matches[$node->nid] = check_plain($node->title) ." [nid: $node->nid]";
    }
  }

  return $matches;
}

/**
 * Collect info about all of the possible nodequeue types from owning
 * modules.
 */
function nodequeue_api_info() {
  return module_invoke_all('nodequeue_info');
}

function nodequeue_api_queue_access($queue, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  if ($queue->owner != 'nodequeue') { // Avoids an infinite loop.
    $function = $queue->owner . '_queue_access';
    if (function_exists($function)) {
      $access = $function($queue, $account);
    }
  }

  if (!isset($access)) {
    $access = TRUE;
  }
  return $access;
}

/**
 * Allows the owning module of a subqueue to restrict access to viewing and
 * manipulating the queue.
 */
function nodequeue_api_subqueue_access($subqueue, $account = NULL, $queue = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  if (!$queue) {
    $queue = nodequeue_load($subqueue->qid);
  }

  $function = $queue->owner . '_subqueue_access';
  if (function_exists($function)) {
    $access = $function($subqueue, $account, $queue);
  }

  if (!isset($access)) {
    $access = TRUE;
  }

  return $access;
}
/**
 * Form builder for the nodequeue settings tab.
 */
function nodequeue_admin_settings() {
  $form = array();
  $form['nodequeue_use_tab'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create a menu tab for each node that could belong to any queues'),
    '#default_value' => variable_get('nodequeue_use_tab', 1),
  );
  $form['nodequeue_tab_display_max'] = array(
    '#type' => 'checkbox',
    '#title' => t('Include a column on the nodequeue tab for the maximum number of nodes in each queue'),
    '#default_value' => variable_get('nodequeue_tab_display_max', 1),
  );
  $form['nodequeue_tab_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Nodequeue tab label'),
    '#default_value' => variable_get('nodequeue_tab_name', t('Nodequeue')),
    '#description' => t('If nodes will have a menu tab for manipulating related nodequeues, what should that tab be called?'),
  );
  $form['nodequeue_view_per_queue'] = array(
    '#type' => 'checkbox',
    '#title' => t('Automatically create one view per queue'),
    '#description' => t("Nodequeue can create a view for each queue. \n
      If you wish to have fewer views, you can disable this option and use a single view with an argument for the qid."),
    '#default_value' => variable_get('nodequeue_view_per_queue', 1),
  );
  return system_settings_form($form);
}

/**
 * Generate a query string to use on nodequeue's private links.
 *
 * @param $seed
 *   The seed to use when generating a token. If NULL no token will
 *   be generated.
 * @param $destination
 *   The destination to use. If FALSE one won't be used; if TRUE
 *   one will be generated from drupal_get_destination().
 * @param $query
 *   An array of additional items to add to the query.
 *
 * @return
 *   The query string suitable for use in the l() function.
 */
function nodequeue_get_query_string($seed, $destination = FALSE, $query = array()) {
  if ($dest = drupal_get_destination()) {
    $query[] = $dest;
  }

  if (isset($seed)) {
    $query[] = nodequeue_get_token($seed);
  }

  return implode('&', $query);
}

/**
 * Get a private token used to protect nodequeue's links from spoofing.
 */
function nodequeue_get_token($nid) {
  return 'token='. drupal_get_token($nid);
}

/**
 * Check to see if the token generated from seed matches.
 */
function nodequeue_check_token($seed) {
  return drupal_get_token($seed) == $_GET['token'];
}

/* --- UTILITY -------------------------------------------------------------- */

/**
 * Helper function - since hook_menu now takes a function instead of a boolean,
 * this function is used to compute the user's access.
 *
 * @return boolean
 */
function _nodequeue_access_admin_or_manipulate() {
  return user_access('administer nodequeue') || user_access('manipulate queues');
}

/* --- THEME ---------------------------------------------------------------- */

/**
 * Theme the subqueue overview as a sortable list.
 *
 * @ingroup themeable
 */
function theme_nodequeue_arrange_subqueue_form($form) {
  $output = '';

  $subqueue = $form['#subqueue'];

  // get css to hide some of the help text if javascript is disabled
  drupal_add_css(drupal_get_path('module', 'nodequeue') .'/nodequeue.css');

  // TODO: Would be nice to expose qid, sqid, reference as classes for more custom theming :).
  // TODO: Create unique ID to make multiple tabledrag forms on a page possible
  drupal_add_tabledrag('nodequeue-dragdrop', 'order', 'sibling', 'node-position');
  drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue_dragdrop.js');

  drupal_add_js(array('nodequeue' => array('reverse' => (bool) $form['#queue']['reverse'])), 'setting');

  // render form as table rows
  $rows = array();
  $counter = 1;
  foreach (element_children($form) as $key) {
    if (isset($form[$key]['title'])) {
      $row = array();

      $row[] = drupal_render($form[$key]['title']);
      $row[] = drupal_render($form[$key]['author']);
      $row[] = drupal_render($form[$key]['date']);
      $row[] = drupal_render($form[$key]['position']);
      $row[] = drupal_render($form[$key]['edit']);
      $row[] = drupal_render($form[$key]['remove']);
      $row[] = array(
        'data' => $counter,
        'class' => 'position'
      );

      $rows[] = array(
        'data'  => $row,
        'class' => 'draggable',
      );
    }

    $counter++;
  }
  if (empty($rows)) {
    $rows[] = array(array('data' => t('No nodes in this queue.'), 'colspan' => 7));
  }

  // render the main nodequeue table
  $header = array(t('Title'), t('Author'), t('Post Date'), t('Position'), array('data' => t('Operations'), 'colspan' => 2), t('Position'));
  $output .= theme('table', $header, $rows, array('id' => 'nodequeue-dragdrop', 'class' => 'nodequeue-dragdrop'));

  // render the autocomplete field for adding a node to the table
  $output .= '<div class="container-inline">';
  $output .= drupal_render($form['add']['nid']);
  $output .= drupal_render($form['add']['submit']);
  $output .= '</div>';

  // render the remaining form elements
  $output .= drupal_render($form);

  return $output;
}

/**
 * Return a "queue is empty" message.
 *
 * @ingroup themeable
 */
function theme_nodequeue_subqueue_empty_text() {
  return t('Queue empty');
}

/**
 * Return a "queue is full" message.
 *
 * @ingroup themeable
 */
function theme_nodequeue_subqueue_full_text() {
  return t('Queue full');
}

/**
 * Return a count of elements in the queue.
 *
 * @ingroup themeable
 */
function theme_nodequeue_subqueue_count_text($count) {
  return t('@count in queue', array('@count' => $count));
}
